(function ( root , factory ) {
    if (typeof define === 'function' && define.amd) {
        define([] , factory );
    }
    else {
        root.MOJO = factory();
    }
}( this , function() {var define, requireModule, require, requirejs;

(function() {
    var registry = {}, seen = {};

    define = function(name, deps, callback) {
        registry[name] = {
            deps: deps,
            callback: callback
        };
    };

    requirejs = require = requireModule = function(name) {
        requirejs._eak_seen = registry;

        if (seen[name]) {
            return seen[name];
        }
        seen[name] = {};

        if (!registry[name]) {
            throw new Error("Could not find module " + name);
        }

        var mod = registry[name],
            deps = mod.deps,
            callback = mod.callback,
            reified = [],
            exports;

        for (var i = 0, l = deps.length; i < l; i++) {
            if (deps[i] === 'exports') {
                reified.push(exports = {});
            } else {
                reified.push(requireModule(resolve(deps[i])));
            }
        }

        var value = callback.apply(this, reified);
        return seen[name] = exports || value;

        function resolve(child) {
            if (child.charAt(0) !== '.') {
                return child;
            }
            var parts = child.split("/");
            var parentBase = name.split("/").slice(0, - 1);

            for (var i = 0, l = parts.length; i < l; i++) {
                var part = parts[i];

                if (part === '..') {
                    parentBase.pop();
                } else if (part === '.') {
                    continue;
                } else {
                    parentBase.push(part);
                }
            }

            return parentBase.join("/");
        }
    };
})();
define("transpiler", function(){});

define('MOJO',[] , function() {

    function MOJO( seed ) {
        var that = this;
        that.__init( that , ( seed || {} ));
    }

    return MOJO;
});




















define('shared',[], function() {

    /*var Array = Array;
    var Object = Object;*/
    var UNDEFINED;
    var PROTO = 'prototype';
    var HANDLE_MOJO = 'handleMOJO';


    function length( subject ) {
        return subject.length;
    }
    

    function isArray( subject ) {
        return Array.isArray( subject );
    }


    function ensureArray( subject ) {
        return (isArray( subject ) ? subject : ( subject !== UNDEFINED ? [ subject ] : [] ));
    }


    function forEach( subject , callback ) {
        return ensureArray( subject ).forEach( callback );
    }


    return {

        EVENTS: {
            $set: '$$set',
            $unset: '$$unset',
            $when: '$$listener.added',
            $emit: '$$listener.triggered',
            $dispel: '$$listener.removed',
            $deref: '$$deref'
        },

        length: length,

        isArray: isArray,

        ensureArray: ensureArray,

        forEach: forEach,

        ocreate: function( subject ) {
            return Object.create( subject );
        },

        defProp: function( subject , property , descriptor ) {
            Object.defineProperty( subject , property , descriptor );
        },

        del: function( subject , key ) {
            delete subject[key];
        },

        keys: function( subject ) {
            return Object.keys( subject );
        },

        shift: function( subject ) {
            return Array[PROTO].shift.call( subject );
        },

        pop: function( subject ) {
            return Array[PROTO].pop.call( subject );
        },

        slice: function( subject , start , end ) {
            return Array[PROTO].slice.call( subject , start , end );
        },

        last: function( subject ) {
            return subject[length( subject ) - 1];
        },

        is: function( subject , test ) {
            return (typeof test === 'string') ? (typeof subject === test) : (subject instanceof test);
        },

        has: function( subject , key ) {
            return subject.hasOwnProperty( key );
        },

        ensureFunc: function( subject ) {
            return subject || function() {};
        },

        getHandlerFunc: function( subject ) {
            return (subject || {})[HANDLE_MOJO] ? subject[HANDLE_MOJO] : subject;
        }
    };
});




























define('inject',[ 'MOJO' , 'shared' ] , function( MOJO , shared ) {

    var is = shared.is;

    function inject( dependencies , callback ) {

        var that = this;

        dependencies = dependencies.map(function( subject ) {
            
            var out;

            if (is( subject , 'string' )) {
                out = shared[subject];
            }
            else {
                out = subject;
            }

            return out;
        });

        return callback.apply( null , dependencies );
    }

    return inject;
});




















define('Event',[ 'inject' ] , function( inject ) {

    return inject(
    [
        Date,
        'forEach',
        'getHandlerFunc',
        'keys',
        'ocreate'
    ],
    function(
        Date,
        forEach,
        getHandlerFunc,
        keys,
        ocreate
    ){


        var PRIVATE_REGEXP = /^\${2}/;
        var CURRENT_TARGET = 'currentTarget';
        var CANCEL_BUBBLE = 'cancelBubble';
        var DEFAULT_PREVENTED = 'defaultPrevented';


        function Event( target , type ) {
            var that = this;
            that.target = target;
            that.type = type;
            that[CURRENT_TARGET] = target;
            that[CANCEL_BUBBLE] = false;
            that[DEFAULT_PREVENTED] = false;
            that.timeStamp = Date.now();
        }


        Event.clone = function( originalEvent , currentTarget ) {
            
            var evtKeys = keys( originalEvent );
            var event = ocreate( originalEvent );
            
            forEach( evtKeys , function( key ) {
                event[key] = originalEvent[key];
            });
            
            event[CURRENT_TARGET] = currentTarget;

            return event;
        };
        

        Event.isPrivate = function( type ) {
            return PRIVATE_REGEXP.test( type );
        };


        Event.getPublic = function( type ) {
            return type.replace( PRIVATE_REGEXP , '' );
        };


        Event.prototype = {

            preventDefault: function() {
                this[DEFAULT_PREVENTED] = true;
            },

            stopPropagation: function() {
                this[CANCEL_BUBBLE] = true;
            }
        };


        return Event;

    });
});




















define('EventHandler',[ 'inject' ] , function( inject ) {

    return inject([ 'ensureArray' ] , function( ensureArray ) {
        
        function EventHandler( func , context , bindArgs ) {

            var that = this;

            that.func = func;
            that.locked = false;
            that.before = function() {};
            that.after = function() {};

            bindArgs = ensureArray( bindArgs );

            that.invoke = function( event , invArgs ) {
                
                if (event.cancelBubble) {
                    return;
                }

                var args = bindArgs
                    .slice( 0 )
                    .concat(
                        ensureArray( invArgs )
                    );

                args.unshift( event );
                that.before( event , func );
                func.apply( context , args );
                that.after( event , func );
            };
        }

        return EventHandler;
    });
});




















/* jshint -W018 */
define('when',[ 'inject' , 'MOJO' , 'Event' , 'EventHandler' ],

function( inject , MOJO , Event , EventHandler ) {

    return inject(
    [
        'keys',
        'ocreate',
        'shift',
        'pop',
        'ensureArray',
        'forEach',
        'length',
        'last',
        'ensureFunc',
        'getHandlerFunc',
        'isArray',
        'is',
        'del',
        'EVENTS'
    ],
    function(
        keys,
        ocreate,
        shift,
        pop,
        ensureArray,
        forEach,
        length,
        last,
        ensureFunc,
        getHandlerFunc,
        isArray,
        is,
        del,
        EVENTS
    ){


        function indexOfHandler( handlerArray , func ) {
            return ensureArray( handlerArray )
                .map(function( evtHandler ) {
                    return evtHandler.func;
                })
                .indexOf( func );
        }
        

        function getHandlerContext( handler , func ) {
            return handler === func ? null : handler;
        }


        function isLockedEvent( type ) {
            var keys = Object.keys( EVENTS );
            var pvt;
            for (var i = 0; i < keys.length; i++) {
                pvt = EVENTS[keys[i]];
                if (pvt === type || Event.getPublic( pvt ) === type) {
                    return true;
                }
            }
        }


        return {

            $once: function() {

                var that = this;

                that.__when( arguments , function( evtHandler ) {
                    evtHandler.before = function( event , func ) {
                        that.$enq(function() {
                            that.__remove( event.type , func );
                        });
                        that.$digest();
                    };
                });

                that.$digest();

                return that;
            },

            $when: function() {
                var that = this;
                that.__when( arguments );
                that.$digest();
                return that;
            },

            $emit: function( eventType , args , originalEvent ) {

                var that = this;

                that.$enq(function() {

                    eventType = that._ensureEType( eventType );

                    forEach( eventType , function( type ) {

                        var handlers = that.__get( type );
                        var event = originalEvent ? Event.clone( originalEvent , that ) : new Event( that , type );
                        
                        forEach( handlers , function( evtHandler ) {
                            evtHandler.invoke( event , args );
                        });

                        if (!isLockedEvent( type )) {
                            that.$emit( EVENTS.$emit , [ type , [ type , args , event ]]);
                        }

                        /*if (!Event.isPrivate( type )) {
                            that.$emit( EVENTS.$emit , [ type , event , args ]);
                        }*/
                    });
                });

                that.$digest();

                return that;
            },

            $dispel: function( eventType , MOJOHandler , force ) {

                var that = this;
                var func = getHandlerFunc( MOJOHandler );

                that.$enq(function() {

                    eventType = that._ensureEType( eventType );

                    forEach( eventType , function( type ) {
                        if (force || !Event.isPrivate( type )) {
                            that.__remove( type , func , !!force );
                        }
                    });
                });

                that.$digest();

                return that;
            },

            /*args = [ eventType , [bindArgs] , [MOJOHandler] ]*/
            __when: function( args , callback ) {

                callback = ensureFunc( callback );

                var that = this;
                var eventType = shift( args );
                var MOJOHandler = is( last( args ) , 'function' ) || is( last( args ) , MOJO ) ? pop( args ) : that;
                var bindArgs = args[0];
                
                var func = getHandlerFunc( MOJOHandler );
                var context = getHandlerContext( MOJOHandler , func );

                that.$enq(function() {
                    forEach( eventType , function( type , i ) {
                        callback(
                            that.__add( type , func , context , bindArgs )
                        );
                    });
                });
            },

            __get: function( eventType ) {
                var that = this;
                var handlers = that.handlers;
                return (eventType ? ensureArray( handlers[eventType] ) : handlers);
            },

            __add: function( type , func , context , args ) {
                
                var that = this;
                var evtHandler = new EventHandler( func , context , args );
                var handlerArray = that.__get( type );

                handlerArray.push( evtHandler );
                that.handlers[type] = handlerArray;

                // emit $$listener.added event
                /*if (!Event.isPrivate( type )) {
                    that.$emit( EVENTS.$when , [ type , func , args ]);
                }*/
                
                /*if (!Event.isPrivate( type )) {
                    that.$emit( EVENTS.$when , [ type , func , args ]);
                }*/
                if (!isLockedEvent( type )) {
                    that.$emit( EVENTS.$when , [ type , [ type , args , func ]]);
                }

                /*if (!Event.isPrivate( type ) && type !== Event.getPublic( EVENTS.$when )) {
                    that.$emit([ EVENTS.$when , Event.getPublic( EVENTS.$when )], [ type , func , args ]);
                }*/

                return evtHandler;
            },

            __remove: function( type , func , force ) {

                var that = this;
                var handlers = that.__get();
                var handlerArray = that.__get( type );
                var i = 0, index, evtHandler;

                while (i < length( handlerArray )) {
                    index = (func ? indexOfHandler( handlerArray , func ) : i);
                    if (index >= 0 && !handlerArray[i].locked) {
                        handlerArray.splice( index , 1 );
                        i--;
                    }
                    i++;
                }
                
                if (!length( handlerArray )) {
                    del( handlers , type );
                }
                else {
                    handlers[type] = handlerArray;
                }

                // emit $$listener.removed event
                /*if (!Event.isPrivate( type )) {
                    that.$emit( EVENTS.$dispel , [ type , func ]);
                }*/
                /*if (!Event.isPrivate( type )) {
                    that.$emit( EVENTS.$dispel , [ type , func ]);
                }*/
                if (!isLockedEvent( type )) {
                    that.$emit( EVENTS.$dispel , [ type , [ type , func , force ]]);
                }
            },

            _ensureEType: function( eventType ) {
                return eventType || keys( this.handlers );
            }
        };
    });
});




















define('construct',[ 'inject' ] , function( inject ) {

    return inject(
    [
        'keys',
        'defProp',
        'length',
        'EVENTS'
    ],
    function(
        keys,
        defProp,
        length,
        EVENTS
    ){

        var HANDLE_MOJO = 'handleMOJO';
        var __HANDLE_MOJO = '__' + HANDLE_MOJO;


        function construct( subject ) {

            var inprog = false;

            defProp( subject , '__inprog' , {
                get: function() {
                    return inprog;
                },
                set: function( value ) {
                    inprog = value;
                }
            });

            defProp( subject , '__stack' , {
                value: []
            });

            defProp( subject , 'handlers' , {
                value: {}
            });

            defProp( subject , 'watchers' , {
                value: []
            });

            defProp( subject , HANDLE_MOJO , {
                value: subject[ HANDLE_MOJO ].bind( subject )
            });

            defProp( subject , __HANDLE_MOJO , {
                value: subject[ __HANDLE_MOJO ].bind( subject )
            });

            keys( EVENTS ).forEach(function( key ) {
                var evt = EVENTS[key];
                var evtHandler = subject.__add( evt , subject[ __HANDLE_MOJO ] , subject );
                evtHandler.locked = true;
            });
        }

        return construct;
    });
});




















define('proto',[ 'MOJO' , 'inject' , 'Event' , 'when' , 'construct' ],

function( MOJO , inject , Event , when , construct ) {
    

    return inject([
        Error,
        'ocreate',
        'shift',
        'pop',
        'slice',
        'length',
        'is',
        'del',
        'EVENTS'
    ],
    function(
        Error,
        ocreate,
        shift,
        pop,
        slice,
        length,
        is,
        del,
        EVENTS
    ){

        var proto = ocreate( when );

        proto.__init = function( that , seed ) {
            for (var key in seed) {
                that[key] = seed[key];
            }
            construct( that );
        };

        proto.__handleMOJO = function() {

            var that = this;
            var args = slice( arguments );
            var e = shift( args );

            /*var shouldEmit = false;
            var pubArgs, type;

            switch (e.type) {

                case EVENTS.$when:
                case EVENTS.$emit:
                case EVENTS.$dispel:
                    type = shift( args );
                    pubArgs = pop( args );
                    shouldEmit = (Event.getPublic( e.type ) !== type);
                break;

                case EVENTS.$set:
                case EVENTS.$unset:
                    shouldEmit = true;
                break;
            }*/

            var type = shift( args );
            var pubArgs = pop( args );
            var shouldEmit = (Event.getPublic( e.type ) !== type);

            /*if (e.type === '$$listener.triggered' && type === '$$gnarly') {
                MOJO.log(pubArgs);
            }*/

            //MOJO.log(e.type + ' -> ' + type);
            //MOJO.log(e.type,pubArgs);

            if (shouldEmit) {
                that.$emit( Event.getPublic( e.type ) , pubArgs );
            }

            if (e.type === EVENTS.$emit && !Event.isPrivate( type )) {
                //MOJO.log(pubArgs);
                that.watchers.forEach(function( watcher ) {
                    //MOJO.log(watcher);
                    watcher.$emit.apply( watcher , pubArgs );
                });
            }

            if (e.type === EVENTS.$emit && Event.isPrivate( type )) {
                /*var pubArgs2 = pubArgs.slice( 0 );
                pubArgs2[0] = Event.getPublic( type );
                //that.$emit.apply( that , pubArgs );
                MOJO.log(pubArgs2);
                MOJO.log(pubArgs);*/
                that.$emit( Event.getPublic( type ) , pubArgs[1] );
            }
        };

        proto.handleMOJO = function() {};

        proto.$set = function( key , value ) {
            var that = this;
            that[key] = value;
            that.$emit( EVENTS.$set , [ key , [ key ]]);
            return that;
        };

        proto.$unset = function( key ) {
            var that = this;
            del( that , key );
            that.$emit( EVENTS.$unset , [ key , [ key ]]);
            return that;
        };

        proto.$watch = function( parent ) {
            
            var that = this;

            if (!is( parent , MOJO )) {
                throw new Error( 'parent must be a MOJO' );
            }

            var watchers = parent.watchers;

            if (watchers.indexOf( that ) < 0) {

                watchers.push( that );

                that.$once( EVENTS.$deref , function( e ) {
                    var i = watchers.indexOf( that );
                    if (i >= 0) {
                        watchers.splice( i , 1 );
                    }
                });
            }

            return that;
        };

        proto.$deref = function() {
            var that = this;
            that.$emit( EVENTS.$deref );
            //that.$dispel( null , null , true );
        };

        proto.$enq = function( task ) {
            var that = this;
            that.__stack.push( task );
        };

        proto.$digest = function() {
            
            var that = this;
            var stack = that.__stack;

            if (that.__inprog) {
                //MOJO.log('--- INPROG ---',stack.length);
                return;
            }

            that.__inprog = true;

            while (length( stack ) > 0) {
                shift( stack )();
            }
            
            that.__inprog = false;
        };

        //del( MOJO , '__ready' );

        return proto;
    });
});




















define('create',[ 'inject' , 'proto' ] , function( inject , prototype ) {

    return inject([ 'ocreate' ] , function( ocreate ){

        function create( proto ) {

            var mojo_proto = ocreate( prototype );

            for (var key in proto) {
                mojo_proto[key] = proto[key];
            }

            return mojo_proto;
        }

        return create;
    });
});




















define('aggregate',[ 'inject' , 'MOJO' , 'Event' ],

function( inject , MOJO , Event ) {

    return inject(
    [
        Error,
        'keys',
        'forEach',
        'EVENTS'
    ],
    function(
        Error,
        keys,
        forEach,
        EVENTS
    ){

        function aggregate( arr ) {

            var er = new MOJO();

            forEach( arr , function( ee ) {
                forEach(keys( EVENTS ) , function( key ) {
                    er.$when( EVENTS[key] , function( e , type , args ) {
                        if (Event.isPrivate( type )) {
                            throw new Error( 'private events cannot be aggregated');
                        }
                        ee[key].apply( ee , args );
                    });
                });
            });

            return er;
        }

        return aggregate;
    });
});




















    
    var MOJO = require( 'MOJO' );
    
    MOJO.prototype = require( 'proto' );
    MOJO.shared = require( 'shared' );
    MOJO.create = require( 'create' );
    MOJO.construct = require( 'construct' );
    MOJO.aggregate = require( 'aggregate' );
    MOJO.Event = require( 'Event' );
    MOJO.EventHandler = require( 'EventHandler' );
    
    return MOJO;
}));